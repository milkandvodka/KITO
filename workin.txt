package com.example.chuut.sap

import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.jsoup.Jsoup
import java.io.IOException
import java.util.concurrent.TimeUnit
import com.example.chuut.BuildConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class SapPortalClient {

    private val client = OkHttpClient.Builder()
        .cookieJar(PersistentCookieJar())
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .addInterceptor { chain ->
            val original = chain.request()
            val requestBuilder = original.newBuilder()
                .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36")
                .header("sec-ch-ua", "\"Google Chrome\";v=\"141\", \"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"141\"")
                .header("sec-ch-ua-mobile", "?0")
                .header("sec-ch-ua-platform", "\"Windows\"")
                .header("sec-fetch-dest", "document")
                .header("sec-fetch-mode", "navigate")
                .header("sec-fetch-site", "same-origin")
                .header("sec-fetch-user", "?1")
                .header("upgrade-insecure-requests", "1")
                .header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7")
                .header("Accept-Language", "en-US,en;q=0.9")
                .header("Cache-Control", "no-cache")
                .header("Pragma", "no-cache")
                .header("DNT", "1")

            val request = requestBuilder.build()
            chain.proceed(request)
        }
        .build()

    suspend fun fetchAttendance(username: String, password: String): AttendanceResult = withContext(Dispatchers.IO) {
        val cookieJar = client.cookieJar as PersistentCookieJar
        cookieJar.clear()

        return@withContext try {
            // STEP 1: GET Login Page
            println("üåê Logging in to Portal...")
            val loginPageResponse = client.newCall(
                Request.Builder()
                    .url("${BuildConfig.PORTAL_BASE}/irj/portal/")
                    .build()
            ).execute()

            if (!loginPageResponse.isSuccessful) {
                return@withContext AttendanceResult.Error("Failed to load login page. Status: ${loginPageResponse.code}")
            }

            val loginPageHtml = loginPageResponse.body?.string()
            loginPageResponse.close()
            val doc = Jsoup.parse(loginPageHtml ?: "")
            val saltElement = doc.selectFirst("input[name=j_salt]")
            val salt = saltElement?.attr("value")

            if (salt.isNullOrEmpty()) {
                return@withContext AttendanceResult.Error("Could not extract j_salt from login page")
            }

            // STEP 2: POST Credentials (WIPE IMMEDIATELY AFTER)
            val loginParams = mapOf(
                "login_submit" to "on",
                "login_do_redirect" to "1",
                "j_salt" to salt!!,
                "j_username" to username,
                "j_password" to password,
                "uidPasswordLogon" to "Log On"
            )

            val loginResponse = client.newCall(
                Request.Builder()
                    .url("${BuildConfig.PORTAL_BASE}/irj/portal/")
                    .post(
                        createFormBody(loginParams)
                    )
                    .addHeader("content-type", "application/x-www-form-urlencoded")
                    .build()
            ).execute()

            if (!loginResponse.isSuccessful) {
                val responseContent = loginResponse.body?.string()
                return@withContext AttendanceResult.Error("Login failed with status: ${loginResponse.code}. Response: ${responseContent?.take(200)}")
            }

            println("‚úÖ Logged in successfully.")

            // WIPE CREDENTIALS IMMEDIATELY AFTER USE
            secureWipe(username.toCharArray())
            secureWipe(password.toCharArray())

            // Check if login was successful
            val loginResultHtml = loginResponse.body?.string()
            loginResponse.close()
            if (loginResultHtml?.contains("authentication failed", true) == true) {
                return@withContext AttendanceResult.Error("Invalid credentials")
            }

            // STEPS 3-5: Navigation Events (Prime session for sap-ext-sid)
            println("üîÑ Performing Navigation Event 1 (Priming Session)...")

            // Navigation Event 1
            val navParams1 = mapOf(
                "NavigationTarget" to "navurl://0e0c5a047a9c52d3e0addf7ac1013956",
                "RelativeNavBase" to "",
                "PrevNavTarget" to "navurl://64b9363e3bf8a96e4d00952307a4e4e4",
                "Command" to "SUSPEND",
                "SerPropString" to "",
                "SerKeyString" to "", // Remove hardcoded GUSID
                "SerAttrKeyString" to "",
                "SerWinIdString" to "",
                "DebugSet" to "",
                "Embedded" to "true",
                "SessionKeysAvailable" to "true"
            )

            val navEvent1Response = client.newCall(
                Request.Builder()
                    .url("${BuildConfig.PORTAL_BASE}/irj/servlet/prt/portal/prteventname/Navigate/prtroot/pcd!3aportal_content!2fevery_user!2fgeneral!2fdefaultDesktop!2fframeworkPages!2fframeworkpage!2fcom.sap.portal.innerpage?InitialNodeFirstLevel=true&sapDocumentRenderingMode=Edge&windowId=WID1761410200722&NavMode=0")
                    .post(createFormBody(navParams1))
                    .addHeader("content-type", "application/x-www-form-urlencoded")
                    .addHeader("referer", "${BuildConfig.PORTAL_BASE}/irj/portal/")
                    .addHeader("sec-fetch-dest", "iframe")
                    .addHeader("sec-fetch-mode", "navigate")
                    .addHeader("sec-fetch-site", "same-origin")
                    .build()
            ).execute()

            if (!navEvent1Response.isSuccessful) {
                return@withContext AttendanceResult.Error("Navigation Event 1 failed with status: ${navEvent1Response.code}")
            }

            println("‚úÖ Navigation Event 1 successful.")

            // Navigation Event 2
            println("üîÑ Performing Navigation Event 2 (Priming Session)...")
            val navParams2 = mapOf(
                "NavigationTarget" to "navurl://56ad2dafd73bcaf4481262d547e0e960",
                "RelativeNavBase" to "",
                "PrevNavTarget" to "navurl://3324181311defe5f50f2009e825ccb2d",
                "Command" to "SUSPEND",
                "SerPropString" to "",
                "SerKeyString" to "",
                "SerAttrKeyString" to "",
                "SerWinIdString" to "",
                "DebugSet" to "",
                "Embedded" to "true",
                "SessionKeysAvailable" to "true"
            )

            val navEvent2Response = client.newCall(
                Request.Builder()
                    .url("${BuildConfig.PORTAL_BASE}/irj/servlet/prt/portal/prteventname/Navigate/prtroot/pcd!3aportal_content!2fevery_user!2fgeneral!2fdefaultDesktop!2fframeworkPages!2fframeworkpage!2fcom.sap.portal.innerpage?ExecuteLocally=true&sapDocumentRenderingMode=Edge&windowId=WID1761410200722&NavMode=0")
                    .post(createFormBody(navParams2))
                    .addHeader("content-type", "application/x-www-form-urlencoded")
                    .addHeader("referer", "${BuildConfig.PORTAL_BASE}/irj/portal/")
                    .addHeader("sec-fetch-dest", "iframe")
                    .addHeader("sec-fetch-mode", "navigate")
                    .addHeader("sec-fetch-site", "same-origin")
                    .build()
            ).execute()

            if (!navEvent2Response.isSuccessful) {
                return@withContext AttendanceResult.Error("Navigation Event 2 failed with status: ${navEvent2Response.code}")
            }

            println("‚úÖ Navigation Event 2 successful.")

            // Navigation Event 3 (Final Prime - Gets sap-ext-sid)
            println("üîÑ Performing Navigation Event 3 (Final Prime - Gets sap-ext-sid)...")
            val navParams3 = mapOf(
                "NavigationTarget" to "navurl://77e29a377213ef8baa4bcb6ecae9a6eb",
                "RelativeNavBase" to "",
                "PrevNavTarget" to "navurl://77e29a377213ef8baa4bcb6ecae9a6eb",
                "Command" to "SUSPEND",
                "SerPropString" to "",
                "SerKeyString" to "", // Keep empty - no hardcoded GUSID
                "SerAttrKeyString" to "",
                "SerWinIdString" to "",
                "DebugSet" to "",
                "Embedded" to "true",
                "SessionKeysAvailable" to "true"
            )

            val navEvent3Response = client.newCall(
                Request.Builder()
                    .url("${BuildConfig.PORTAL_BASE}/irj/servlet/prt/portal/prteventname/Navigate/prtroot/pcd!3aportal_content!2fevery_user!2fgeneral!2fdefaultDesktop!2fframeworkPages!2fframeworkpage!2fcom.sap.portal.innerpage?buildTree=false&NavPathUpdate=false&sapDocumentRenderingMode=Edge&windowId=WID1761410200722&NavMode=0")
                    .post(createFormBody(navParams3))
                    .addHeader("content-type", "application/x-www-form-urlencoded")
                    .addHeader("referer", "${BuildConfig.PORTAL_BASE}/irj/portal/")
                    .addHeader("sec-fetch-dest", "iframe")
                    .addHeader("sec-fetch-mode", "navigate")
                    .addHeader("sec-fetch-site", "same-origin")
                    .build()
            ).execute()

            if (!navEvent3Response.isSuccessful) {
                return@withContext AttendanceResult.Error("Navigation Event 3 failed with status: ${navEvent3Response.code}")
            }

            // === AFTER NAVIGATION EVENT 3 ===
            println("‚úÖ Navigation Event 3 successful.")

            // Get the HTML from Navigation Event 3 response and look for the Web Dynpro form in the navigation response
            val nav3Html = navEvent3Response.body?.string()
            navEvent3Response.close()
            val nav3Doc = Jsoup.parse(nav3Html ?: "")

            // Look for the Web Dynpro form in the navigation response (as per fetch_attendance.js)
            val wdForm = nav3Doc.selectFirst("form[name=\"isolatedWorkAreaForm\"]")
            val wdFormAction = wdForm?.attr("action")

            if (wdFormAction.isNullOrEmpty()) {
                return@withContext AttendanceResult.Error("Could not find Web Dynpro form (named 'isolatedWorkAreaForm') in navigation response. Response snippet: ${(nav3Html ?: "").take(500)}")
            }

            // Extract sap-ext-sid from the form action URL
            val sapExtSidRegex = Regex("sap-ext-sid=([^&]+)")
            val sapExtSidMatch = sapExtSidRegex.find(wdFormAction)
            val sapExtSid = sapExtSidMatch?.groupValues?.get(1)

            if (sapExtSid.isNullOrEmpty()) {
                return@withContext AttendanceResult.Error("Could not extract sap-ext-sid from form action. Action: $wdFormAction")
            }

            println("üîë Extracted sap-ext-sid: $sapExtSid")

            // Extract all form fields as per fetch_attendance.js
            val formData = mutableMapOf<String, String>()
            wdForm.select("input[type=\"hidden\"]").forEach { input ->
                val name = input.attr("name")
                val value = input.attr("value")
                if (name.isNotEmpty()) {
                    formData[name] = value
                    println("üîë Form field: $name=${if(value.length > 30) "${value.take(30)}..." else value}")
                }
            }

            // Submit Web Dynpro form (as per fetch_attendance.js)
            println("üåê Submitting Web Dynpro form to initialize session...")
            val wdHost = "https://wdprd.kiituniversity.net:8001" // ‚úÖ NO TRAILING SPACES!
            val wdEndpoint = "/sap/bc/webdynpro/sap/ZWDA_HRIQ_ST_ATTENDANCE"
            val wdInitialResponse = client.newCall(
                Request.Builder()
                    .url(wdFormAction)  // Use the actual form action URL from the isolatedWorkAreaForm
                    .post(createFormBody(formData))
                    .addHeader("Content-Type", "application/x-www-form-urlencoded")
                    .addHeader("Referer", navEvent3Response.request.url.toString())
                    .addHeader("Origin", wdHost)
                    .addHeader("Sec-Fetch-Dest", "iframe")
                    .addHeader("Sec-Fetch-Mode", "navigate")
                    .addHeader("Sec-Fetch-Site", "cross-site")
                    .addHeader("Upgrade-Insecure-Requests", "1")
                    .addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7")
                    .addHeader("Accept-Language", "en-US,en;q=0.9")
                    .addHeader("DNT", "1")
                    .addHeader("Priority", "u=0, i")
                    .addHeader("Sec-Ch-Ua", "\"Google Chrome\";v=\"141\", \"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"141\"")
                    .addHeader("Sec-Ch-Ua-Mobile", "?0")
                    .addHeader("Sec-Ch-Ua-Platform", "\"Windows\"")
                    .addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36")
                    .build()
            ).execute()

            if (!wdInitialResponse.isSuccessful) {
                return@withContext AttendanceResult.Error("Web Dynpro form submission failed with status: ${wdInitialResponse.code}")
            }

            println("‚úÖ Web Dynpro form submitted. Status: ${wdInitialResponse.code}")

            // Extract contextId and secureId from the response
            val wdResponseHtml = wdInitialResponse.body?.string()
            wdInitialResponse.close()
            val wdDocFinal = Jsoup.parse(wdResponseHtml ?: "")

            // Extract sap-contextid from multiple possible sources
            var wdContextId = ""
            val contextIdPatterns = listOf(
                Regex("sap.contextid[=:]['\"]?([^'\"&>]+)", RegexOption.IGNORE_CASE),
                Regex("sap-contextid=([^&\"]+)"),
                Regex("name=['\"]sap-contextid['\"][^>]*value=['\"]([^'\"]+)['\"]")
            )

            for (pattern in contextIdPatterns) {
                val match = pattern.find(wdResponseHtml ?: "")
                if (match != null && match.groupValues.size > 1) {
                    wdContextId = match.groupValues[1].replace(Regex("['\"]"), "")
                    break
                }
            }

            // Fallback: try to extract from the response URL
            if (wdContextId.isEmpty()) {
                val reqUrl = wdInitialResponse.request.url
                wdContextId = reqUrl.queryParameter("sap-contextid") ?: ""
            }

            if (wdContextId.isEmpty()) {
                println("‚ö†Ô∏è Could not extract sap-contextid from the response. Using a default value.")
                // Generate a default context ID as fallback
                wdContextId = "SID:ANON:${System.currentTimeMillis()}:${(Math.random() * 10000).toInt()}"
                println("üîß Using generated contextId: $wdContextId")
            }

            println("üîë Found sap-contextid: $wdContextId")

            // Extract sap-wd-secure-id
            var secureId = ""

            // 1. Try direct input field
            val secureIdInput = wdDocFinal.selectFirst("input[name=\"sap-wd-secure-id\"]")
            secureId = secureIdInput?.attr("value")?.trim() ?: ""

            // 2. Try alternative secure ID fields
            if (secureId.isEmpty()) {
                val altSecureInput = wdDocFinal.selectFirst("input[name*=\"secure\" i], input[id*=\"secure\" i]")
                secureId = altSecureInput?.attr("value")?.trim() ?: ""
            }

            // 3. Try to extract from JavaScript content
            if (secureId.isEmpty()) {
                val jsSecureIdPattern = Regex("sap-wd-secure-id[^>]*value=[\"']([^\"']+)[\"']|secureId[^>]*[\"']([^\"']+)[\"']")
                val jsMatch = jsSecureIdPattern.find(wdResponseHtml ?: "")
                if (jsMatch != null && jsMatch.groupValues.size > 1) {
                    secureId = jsMatch.groupValues.filter { it.isNotEmpty() }.getOrNull(1) ?: ""
                }
            }

            // 4. Last resort: look for 32-character hex ID
            if (secureId.isEmpty()) {
                val hexPattern = Regex("[A-F0-9]{32}", RegexOption.IGNORE_CASE)
                val potentialIds = hexPattern.findAll(wdResponseHtml ?: "").toList()
                if (potentialIds.isNotEmpty()) {
                    secureId = potentialIds.first().value
                    println("üîç Found potential secure ID using pattern matching")
                }
            }

            if (secureId.isEmpty()) {
                println("‚ö†Ô∏è Could not extract secure ID from the response. Using a default value.")
                // Generate a random secure ID as fallback (32 hex characters)
                secureId = (1..32).map { "0123456789ABCDEF".random() }.joinToString("")
                println("üîß Using generated secure ID: $secureId")
            }

            println("üîë Found secure ID: $secureId")

            // Extract additional tokens from the form action if present (as per fetch_attendance.js)
            var extSidFromForm: String? = null
            var contextIdFromForm: String? = null

            // Look for the SAP client form and extract tokens from its action attribute
            val sapClientForm = wdDocFinal.selectFirst("form[name=\"sap.client.SsrClient.form\"]")
            val formAction = sapClientForm?.attr("action")

            if (!formAction.isNullOrEmpty()) {
                println("üîç Found form action: ${if(formAction.length > 100) "${formAction.take(100)}..." else formAction}")

                // Decode HTML entities first (&#x3b; = ;, &#x3f; = ?) as in JS
                var decodedAction = formAction
                    .replace("&#x3b;", ";") // Replace &#x3b; with ;
                    .replace("&#x3f;", "?") // Replace &#x3f; with ?

                // Extract sap-ext-sid - match JS pattern exactly
                val extSidMatch = Regex(""";sap-ext-sid=([^?&]+)""", RegexOption.IGNORE_CASE).find(decodedAction)
                extSidFromForm = extSidMatch?.groupValues?.getOrNull(1)

                // Extract sap-contextid - match JS pattern exactly
                val contextIdMatch = Regex("""[?&]sap-contextid=([^&]+)""", RegexOption.IGNORE_CASE).find(decodedAction)
                if (contextIdMatch != null && contextIdMatch.groupValues.size > 1) {
                    contextIdFromForm = java.net.URLDecoder.decode(contextIdMatch.groupValues[1], "UTF-8")
                }
            } else {
                println("‚ö†Ô∏è No form action found in the response")
            }

            // Determine the final values to use - prioritize tokens found in the WD form action if present
            val finalExtSid = extSidFromForm ?: sapExtSid
            var finalContextId = contextIdFromForm ?: wdContextId

            // ALSO extract from the response URL if the form action extraction failed
            if (finalContextId == wdContextId) { // If we didn't get it from form action
                val responseUrl = wdInitialResponse.request.url.toString()
                val urlContextIdMatch = Regex("""[?&]sap-contextid=([^&]+)""", RegexOption.IGNORE_CASE).find(responseUrl)
                if (urlContextIdMatch != null && urlContextIdMatch.groupValues.size > 1) {
                    val urlContextId = java.net.URLDecoder.decode(urlContextIdMatch.groupValues[1], "UTF-8")
                    if (urlContextId.isNotEmpty()) {
                        finalContextId = urlContextId
                        println("üîë Found sap-contextid in response URL: $urlContextId")
                    }
                }
            }

            println("--- Final Token Extraction ---")
            println("sap-ext-sid (from Nav step or WD form): $finalExtSid")
            println("sap-contextid (from WD form): $finalContextId")
            println("sap-wd-secure-id (from WD input): $secureId")
            println("")

            // Validate we have all required tokens
            if (finalExtSid.isEmpty() || finalContextId.isEmpty() || secureId.isEmpty()) {
                return@withContext AttendanceResult.Error("Missing required tokens: ext-sid=${finalExtSid.isNotEmpty()}, context-id=${finalContextId.isNotEmpty()}, secure-id=${secureId.isNotEmpty()}")
            }

            println("‚úÖ All tokens found: ext-sid=$finalExtSid, ctx-id=$finalContextId, secure-id=$secureId")

            // FIRST: Send initial request to load default attendance data (as per fetch_attendance.js)
            println("üì° Sending initial attendance load request (loading default data)...")
            val initialUrl = "$wdHost$wdEndpoint;sap-ext-sid=$finalExtSid?sap-contextid=${java.net.URLEncoder.encode(finalContextId, "UTF-8")}"
            val initialBody = mapOf(
                "sap-charset" to "utf-8",
                "sap-wd-secure-id" to secureId,
                "fesrAppName" to "ZWDA_HRIQ_ST_ATTENDANCE",
                "SAPEVENTQUEUE" to "Form_Request~E002Id~E004sap.client.SsrClient.form~E005Async~E004false~E005FocusInfo~E004~0040~007B~0022sFocussedId~0022~003A~0022~0022~007D~E005Hash~E004~E005DomChanged~E004false~E005IsDirty~E004false~E003~E002ResponseData~E004delta~E003~E002~E003~E002~E003"
            )

            val initialHeaders = mapOf(
                "accept" to "*/*",
                "accept-language" to "en-US,en;q=0.9",
                "content-type" to "application/x-www-form-urlencoded",
                "dnt" to "1",
                "priority" to "u=1, i",
                "referer" to "$wdHost$wdEndpoint;sap-ext-sid=$finalExtSid",
                "sec-ch-ua" to "\"Google Chrome\";v=\"141\", \"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"141\"",
                "sec-ch-ua-mobile" to "?0",
                "sec-ch-ua-platform" to "\"Windows\"",
                "sec-fetch-dest" to "empty",
                "sec-fetch-mode" to "cors",
                "sec-fetch-site" to "same-origin",
                "user-agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36",
                "x-requested-with" to "XMLHttpRequest",
                "x-xhr-logon" to "accept"
            )

            val initialResponse = client.newCall(
                Request.Builder()
                    .url(initialUrl)
                    .post(createFormBody(initialBody))
                    .apply {
                        initialHeaders.forEach { (key, value) ->
                            addHeader(key, value)
                        }
                    }
                    .build()
            ).execute()

            if (!initialResponse.isSuccessful) {
                val responseContent = initialResponse.body?.string()
                initialResponse.close()
                return@withContext AttendanceResult.Error("Initial attendance load failed with status: ${initialResponse.code}. Response: ${responseContent?.take(200)}")
            }

            println("‚úÖ Initial attendance load successful. Status: ${initialResponse.code}")

            // NOW: Send the full request with year/session selection (as per fetch_attendance.js)
            println("üìÖ Selecting Academic Year and Session from WD response...")

            // Debug: Show what the WD response HTML contains
            println("üîç WD Response HTML for dropdown extraction (first 1000 chars): ${wdResponseHtml?.take(1000)}")

            // Parse the WD response HTML to extract the actual academic year and term code values from dropdowns
            var academicYearValue = "2025" // fallback
            var termCodeValue = "010"     // fallback
            val wdParsed = Jsoup.parse(wdResponseHtml ?: "")
            println("üîç Parsing WD response to extract year and session values...")

            // --- Extract Year ---
            println("üîç Looking for Year Popup List (ID: WD53)...")
            val yearPopupList = wdParsed.selectFirst("#WD53")
            if (yearPopupList != null) {
                println("‚úÖ Found Year Popup List (WD53)")
                val yearItems = yearPopupList.select(".lsListbox__value")
                println("üîç Found ${yearItems.size} year items in popup list")
                if (yearItems.isNotEmpty()) {
                    // Get the last year item (most recent) and extract its internal data-itemkey
                    val lastYearItem = yearItems.last()
                    academicYearValue = lastYearItem?.attr("data-itemkey") ?: lastYearItem?.attr("data-value") ?: "2025"
                    println("üìÖ Academic year key extracted from popup list: $academicYearValue")
                } else {
                    // Fallback: try to find the current value directly in the combobox input
                    val yearInput = wdParsed.selectFirst("#WD52")
                    if (yearInput != null) {
                        val inputValue = yearInput.attr("value")
                        println("üîç Year input value: $inputValue")
                        if (inputValue.isNotBlank()) {
                            academicYearValue = inputValue
                            println("üìÖ Academic year value extracted from combobox input: $academicYearValue")
                        }
                    }
                }
            } else {
                println("‚ö†Ô∏è Year Popup List (WD53) not found. Using fallback: 2025")
            }

            // --- Extract Session ---
            println("üîç Looking for Session Popup List (ID: WD70)...")
            val sessionPopupList = wdParsed.selectFirst("#WD70")
            if (sessionPopupList != null) {
                println("‚úÖ Found Session Popup List (WD70)")
                val sessionItems = sessionPopupList.select(".lsListbox__value")
                println("üîç Found ${sessionItems.size} session items in popup list")
                if (sessionItems.isNotEmpty()) {
                    // Find the Autumn session (010) specifically, or default to first item
                    val autumnItem = sessionItems.select("[data-itemkey=010]")
                    if (autumnItem.isNotEmpty()) {
                        termCodeValue = autumnItem.first()?.attr("data-itemkey") ?: "010"
                        println("üìÖ Autumn session key (010) found in popup list: $termCodeValue")
                    } else {
                        // If Autumn not found, get the first available session
                        val firstSessionItem = sessionItems.first()
                        termCodeValue = firstSessionItem?.attr("data-itemkey") ?: firstSessionItem?.attr("data-value") ?: "010"
                        println("üìÖ First available session key extracted from popup list: $termCodeValue")
                    }
                } else {
                    // Fallback: try to find the current value directly in the combobox input
                    val sessionInput = wdParsed.selectFirst("#WD6F")
                    if (sessionInput != null) {
                        val inputValue = sessionInput.attr("value")
                        println("üîç Session input value: $inputValue")
                        if (inputValue.isNotBlank()) {
                            termCodeValue = inputValue
                            println("üìÖ Session value extracted from combobox input: $termCodeValue")
                        }
                    }
                }
            } else {
                println("‚ö†Ô∏è Session Popup List (WD70) not found. Using fallback: 010")
            }

            println("üìÖ Final Academic Year Key: $academicYearValue")
            println("üìÖ Final Term Code Key: $termCodeValue")

            // Build SAPEVENTQUEUE with year/session selection as per fetch_attendance.js
            val encodedExtSid = java.net.URLEncoder.encode(finalExtSid.replace("*", "*").replace("-", "--"), "UTF-8")
            val sapeventQueue =
                "ClientInspector_Notify~E002Id~E004WD01~E005Data~E004CssMatchesHtmlVersion~003ATRUE~003BClientURL~003Ahttps~003A~002F~002Fwdprd.kiituniversity.net~003A8001~002Fsap~002Fbc~002Fwebdynpro~002Fsap~002FZWDA_HRIQ_ST_ATTENDANCE~003Bsap-ext-sid~003D${encodedExtSid}~E003~E002ResponseData~E004delta~E005EnqueueCardinality~E004single~E003~E002~E003~E001" +
                "ComboBox_Select~E002Id~E004WD52~E005Key~E004${java.net.URLEncoder.encode(academicYearValue, "UTF-8")}~E003~E002ResponseData~E004delta~E005EnqueueCardinality~E004single~E003~E002~E003~E001" +
                "ComboBox_Select~E002Id~E004WD6F~E005Key~E004${java.net.URLEncoder.encode(termCodeValue, "UTF-8")}~E003~E002ResponseData~E004delta~E005EnqueueCardinality~E004single~E003~E002~E003~E001" +
                "Button_Press~E002Id~E004WD7C~E003~E002ResponseData~E004delta~E005ClientAction~E004submit~E003~E002~E003~E001" +
                "Form_Request~E002Id~E004sap.client.SsrClient.form~E005Async~E004false~E005FocusInfo~E004~0040~007B~0022sFocussedId~0022~003A~0022WD7C~0022~007D~E005Hash~E004~E005DomChanged~E004false~E005IsDirty~E004false~E003~E002ResponseData~E004delta~E003~E002~E003"

            val attendanceBody = mapOf(
                "sap-charset" to "utf-8",
                "sap-wd-secure-id" to secureId,
                "fesrAppName" to "ZWDA_HRIQ_ST_ATTENDANCE",
                "SAPEVENTQUEUE" to sapeventQueue
            )

            val attendanceResponse = client.newCall(
                Request.Builder()
                    .url(initialUrl) // Use same URL as initial request
                    .post(createFormBody(attendanceBody))
                    .apply {
                        initialHeaders.forEach { (key, value) ->
                            addHeader(key, value)
                        }
                    }
                    .build()
            ).execute()

            if (!attendanceResponse.isSuccessful) {
                val responseContent = attendanceResponse.body?.string()
                attendanceResponse.close()
                return@withContext AttendanceResult.Error("Attendance request failed with status: ${attendanceResponse.code}. Response: ${responseContent?.take(200)}")
            }

            println("‚úÖ Attendance request successful. Status: ${attendanceResponse.code}")

            val attendanceHtml = attendanceResponse.body?.string()
            attendanceResponse.close()

            // Add debugging logs as suggested
            println("üîó Attendance URL: $initialUrl")
            println("üìÑ Raw attendance response (first 1000 chars):\n${attendanceHtml?.take(1000)}")
            println("üìÑ Full response length: ${attendanceHtml?.length}")

            // Parse attendance data from the response
            val parsedAttendance = parseAttendanceData(attendanceHtml ?: "")

            // Logout after successful attendance fetch
            performLogout()

            AttendanceResult.Success(parsedAttendance)

        } catch (e: IOException) {
            performLogout() // Attempt logout even on error
            AttendanceResult.Error("Network error: ${e.message ?: e.javaClass.simpleName}")
        } catch (e: Exception) {
            performLogout() // Attempt logout even on error
            println("‚ùå General error during attendance fetch: ${e.message}")
            e.printStackTrace() // Print stack trace for debugging
            AttendanceResult.Error("Unexpected error: ${e.message ?: e.javaClass.simpleName}")
        }
    }

    private fun createFormBody(params: Map<String, String>): RequestBody {
        val formBuilder = FormBody.Builder()
        for ((key, value) in params) {
            formBuilder.add(key, value)
        }
        return formBuilder.build()
    }

    private fun secureWipe(charArray: CharArray) {
        for (i in charArray.indices) {
            charArray[i] = '0'
        }
    }

    private fun parseAttendanceData(rawResponse: String): AttendanceData {
        /* ---------- 1. Grab the HTML that contains the table ---------- */
        val cdata = Regex("""<content-update[^>]*>\s*<!\[CDATA\[([\s\S]*?)]]>\s*</content-update>""", RegexOption.IGNORE_CASE)
            .find(rawResponse)?.groupValues?.get(1)
            ?: throw Exception("No <content-update> CDATA found")

        /* ---------- 2. Build column map from real <th> texts ---------- */
        val thRegex = Regex("""<th[^>]*>(.*?)</th>""", RegexOption.IGNORE_CASE)
        val headers = thRegex.findAll(cdata)
            .map {
                val content = it.groupValues[1]
                // Clean up HTML tags and entities
                content.replace(Regex("""<[^>]*>"""), " ")
                    .replace(Regex("""\s+"""), " ")
                    .trim()
            }
            .toList()

        val colMap = mutableMapOf<String, Int>()
        headers.forEachIndexed { idx, h ->
            when {
                h.contains("subject", ignoreCase = true) -> colMap["subject"] = idx
                h.contains("present", ignoreCase = true) -> colMap["present"] = idx
                h.contains("total", ignoreCase = true) && h.contains("day", ignoreCase = true) -> colMap["total"] = idx
                h.contains("absent", ignoreCase = true) -> colMap["absent"] = idx
                h.contains("excuse", ignoreCase = true) -> colMap["excuses"] = idx
                h.contains("percentage", ignoreCase = true) || h.contains("%", ignoreCase = true) -> colMap["percent"] = idx
                h.contains("faculty", ignoreCase = true) && h.contains("id", ignoreCase = true) -> colMap["facId"] = idx
                h.contains("faculty", ignoreCase = true) && !h.contains("id", ignoreCase = true) -> colMap["facName"] = idx
            }
        }
        println("üìä headers = $headers")
        println("üìä colMap  = $colMap")

        /* ---------- 3. Collect <tr rr="N"> data rows ---------- */
        val rowRegex = Regex("""<tr[^>]*\srr="([1-9]\d*)"[^>]*>(.*?)</tr>""", setOf(RegexOption.DOT_MATCHES_ALL, RegexOption.IGNORE_CASE))
        val subjects = mutableListOf<SubjectAttendance>()

        rowRegex.findAll(cdata).forEach { rowMatch ->
            var cells = cellTexts(rowMatch.groupValues[2]) // visible text per <td>
            if (cells.isEmpty()) return@forEach

            println("üîç Raw row cells: $cells")

            // Check if we need to drop the first cell (checkbox/selection column that has no header)
            var adjustedCells = cells
            var adjustedColMap = colMap

            if ((cells.size > headers.size && cells.firstOrNull()?.isBlank() == true) ||
                cells.firstOrNull()?.trim() == "&nbsp;") {
                val droppedCell = cells.first()
                adjustedCells = cells.drop(1)  // Remove the checkbox column
                println("‚úÇÔ∏è Dropped first cell ($droppedCell), adjusted to: $adjustedCells")

                // Adjust the column map indices since we removed the first column
                // All original indices need to be reduced by 2 to account for the removed checkbox column
                // The original mapping was calculated with an offset where headers[2] (Subject) corresponded to cells[0] (first data)
                // So to map from original structure to new structure: subtract 2
                adjustedColMap = colMap.mapValues { entry ->
                    entry.value - 2  // Reduce each index by 2
                }.toMutableMap()

                println("üîß Adjusted column map: $adjustedColMap")
            }

            // Now use the adjusted cells and column map
            var finalCells = adjustedCells
            var finalColMap = adjustedColMap

            // Only require the essential columns to be present, not all mapped columns
            // Map required indices for our data model (using adjusted column map)
            val subjectIndex = finalColMap["subject"]
            val presentIndex = finalColMap["present"]
            val totalIndex = finalColMap["total"]
            val excusesIndex = finalColMap["excuses"]
            val percentIndex = finalColMap["percent"]

            // Only require subject, present, total, and percent - absent can be calculated
            if (subjectIndex == null || presentIndex == null || totalIndex == null || percentIndex == null) {
                println("‚ö†Ô∏è Skipping row: missing required column indices (subject, present, total, or percent)")
                return@forEach
            }

            // Check if we have enough cells for the required indices
            var maxEssentialIndex = if (excusesIndex != null) {
                maxOf(subjectIndex, presentIndex, totalIndex, percentIndex, excusesIndex)
            } else {
                maxOf(subjectIndex, presentIndex, totalIndex, percentIndex)
            }

            if (finalCells.size <= maxEssentialIndex) {
                println("‚ö†Ô∏è Skipping row: only ${finalCells.size} cells, need at least ${maxEssentialIndex + 1}")
                return@forEach
            }

            // Safely get each field by mapped column index with proper logging
            val subjectNameRaw = finalCells[subjectIndex].trim()
            val presentRaw = finalCells[presentIndex].trim()
            val totalRaw = finalCells[totalIndex].trim()
            val excusesRaw = if (excusesIndex != null && finalCells.size > excusesIndex) finalCells[excusesIndex].trim() else "0"
            val percentRaw = finalCells[percentIndex].trim()

            // Calculate absent from present and total
            val present = presentRaw.toDoubleOrNull() ?: 0.0
            val total = totalRaw.toDoubleOrNull() ?: 0.0
            val absent = total - present
            val excuses = excusesRaw.toDoubleOrNull() ?: 0.0
            val percentage = percentRaw.toDoubleOrNull() ?: (if (total > 0) (present / total * 100) else 0.0)

            // Decode HTML entities in subject name to fix special characters
            val subjectName = decodeHtmlEntities(subjectNameRaw)

            // Try to get faculty name from the appropriate column if available
            val facultyNameIndex = finalColMap["facName"]
            val facultyName = if (facultyNameIndex != null && finalCells.size > facultyNameIndex) {
                decodeHtmlEntities(finalCells[facultyNameIndex].trim())
            } else {
                ""
            }

            println("üîç Raw cell values - Subject: '$subjectNameRaw', Present: '$presentRaw', Total: '$totalRaw', Excuses: '$excusesRaw', %: '$percentRaw'")
            println("üìä Calculated - Absent: $absent, Percentage: $percentage")
            println("üìä Row - Subject: '$subjectName', Present: $present, Total: $total, %: $percentage, Faculty: '$facultyName'")
            subjects += SubjectAttendance(
                subjectCode = "",
                subjectName = subjectName,
                attendedClasses = present.toInt(),
                totalClasses = total.toInt(),
                percentage = percentage,
                facultyName = facultyName
            )
        }

        println("‚úÖ Parsed ${subjects.size} subjects")
        if (subjects.isEmpty()) {
            // Optional: add a fallback warning if headers exist but no rows matched
            throw Exception("No attendance rows parsed. Headers: $headers | Raw snippet: ${cdata.take(500)} | Column map: $colMap")
        }
        return AttendanceData(subjects)
    }

    /* ------------------ helper functions ------------------ */
    private fun trimTags(input: String): String =
        input.replace(Regex("""<[^>]*>"""), " ")
            .replace(Regex("""\s+"""), " ")

    private fun cellTexts(trFragment: String): List<String> {
        val tdRegex = Regex("""<td[^>]*>(.*?)</td>""", setOf(RegexOption.DOT_MATCHES_ALL, RegexOption.IGNORE_CASE))
        return tdRegex.findAll(trFragment)
            .map { trimTags(it.groupValues[1]).trim() }
            .toList()
    }

    private fun decodeHtmlEntities(input: String): String {
        var result = input
            // Decode common HTML entities
            .replace("&amp;", "&")
            .replace("&lt;", "<")
            .replace("&gt;", ">")
            .replace("&quot;", "\"")
            .replace("&apos;", "'")
            // Decode hex entities like &#x20; (space)
            .replace(Regex("""&#x([0-9a-fA-F]+);""")) {
                val hex = it.groupValues[1]
                try {
                    String(intArrayOf(Integer.parseInt(hex, 16)), 0, 1)
                } catch (e: Exception) {
                    it.value // return original if invalid
                }
            }
            // Decode decimal entities like &#32; (space)
            .replace(Regex("""&#(\d+);""")) {
                val dec = it.groupValues[1]
                try {
                    String(intArrayOf(dec.toInt()), 0, 1)
                } catch (e: Exception) {
                    it.value // return original if invalid
                }
            }
        return result
    }

    private fun performLogout() {
        try {
            val logoutUrl = "${BuildConfig.PORTAL_BASE}/irj/servlet/prt/portal/prtroot/com.sap.portal.navigation.masthead.LogOutComponent"

            val logoutResponse = client.newCall(
                Request.Builder()
                    .url(logoutUrl)
                    .post(createFormBody(mapOf("logout_submit" to "true")))
                    .addHeader("content-type", "application/x-www-form-urlencoded")
                    .addHeader("origin", BuildConfig.PORTAL_BASE)
                    .addHeader("referer", "${BuildConfig.PORTAL_BASE}/irj/portal/")
                    .build()
            ).execute()

            if (logoutResponse.isSuccessful) {
                println("‚úÖ Logout completed successfully.")
            } else {
                println("‚ö†Ô∏è Logout completed with status: ${logoutResponse.code}")
            }
            logoutResponse.close()
        } catch (e: Exception) {
            println("‚ö†Ô∏è Error during logout: ${e.message}")
        }
    }
}

sealed class AttendanceResult {
    data class Success(val data: AttendanceData) : AttendanceResult()
    data class Error(val message: String) : AttendanceResult()
}

data class AttendanceData(
    val subjects: List<SubjectAttendance> = emptyList()
)

data class SubjectAttendance(
    val subjectCode: String,
    val subjectName: String,
    val attendedClasses: Int,
    val totalClasses: Int,
    val percentage: Double,
    val facultyName: String = ""
)

// Enhanced cookie jar for cross-domain SAP session sharing
class PersistentCookieJar : CookieJar {
    private val cookieStore = mutableListOf<Cookie>()

    override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {
        for (cookie in cookies) {
            // Remove cookies that match name/domain/path first
            cookieStore.removeAll {
                it.name == cookie.name && it.domain == cookie.domain && it.path == cookie.path
            }
            // Add new cookie
            cookieStore.add(cookie)
        }
    }

    override fun loadForRequest(url: HttpUrl): List<Cookie> {
        val currentTime = System.currentTimeMillis()
        return cookieStore.filter { cookie ->
            // Check if cookie is valid for this request
            isCookieValidForRequest(cookie, url, currentTime)
        }
    }

    private fun isCookieValidForRequest(cookie: Cookie, requestUrl: HttpUrl, currentTime: Long): Boolean {
        // Check expiration
        if (cookie.expiresAt <= currentTime) return false

        // Check domain - allow subdomain matching for SAP portals
        val requestHost = requestUrl.host.lowercase()
        var cookieDomain = cookie.domain.lowercase()
        if (!cookieDomain.startsWith(".")) {
            cookieDomain = ".$cookieDomain"
        }

        // Domain matching (allows subdomain access for SAP environments)
        if (!requestHost.endsWith(cookieDomain) && requestHost != cookieDomain.removePrefix(".")) {
            return false
        }

        // Path matching
        if (!requestUrl.encodedPath.startsWith(cookie.path)) {
            return false
        }

        // HTTPS requirement if secure
        if (cookie.secure && requestUrl.scheme != "https") {
            return false
        }

        return true
    }

    fun clear() {
        cookieStore.clear()
    }
}